{% extends '@Twig/Exception/error.html.twig' %}

{% block title %}{{ tr('page_not_found_title') }}{% endblock %}

{% block image %}{{ asset('images/error/clanger_error.gif') }}{% endblock %}
{% block pagenote %}{{ tr('page_not_found_note') }}{% endblock %}

{% block javascripts %}
    <script>
        document.getElementsByClassName('grid')[1].children[0].addEventListener('click', () => {
            require(['pixi'], PIXI => {
                const app = new PIXI.Application({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: 0x000000,
                    resolution: window.devicePixelRatio || 1,
                    autoResize: true
                });

                const view = app.view;
                const element = document.getElementsByClassName('programmes-page')[0];
                element.parentElement.replaceChild(view, element);
                view.scrollIntoView(true);

                const stage = app.stage;

                const container = new PIXI.Container();
                stage.addChild(container);

                const screen = app.screen;
                const screenWidth = screen.width;
                const screenHeight = screen.height;

                const moonRadius = screenWidth * 3;
                container.addChild(new PIXI.Graphics()
                    .beginFill(0xFFFFFF)
                    .drawCircle(moonRadius, moonRadius, moonRadius)
                    .endFill());

                container.x = screenWidth / 2;
                container.y = (screenHeight * 0.75) + moonRadius;

                container.pivot.x = moonRadius;
                container.pivot.y = moonRadius;

                const ticker = app.ticker;
                const obstacleQueue = [];

                // Player
                var player = stage.addChild(new PIXI.Graphics()
                    .beginFill(0xE4919E) // Clanger colour
                    .drawRect(500, 450, 50, 75)
                    .endFill());

                const jump = () => {
                    // TODO: go down again
                    player.y -= 100;
                }

                const crouch = () => {
                    // TODO: go up again
                    player.y += 100;
                }

                // Controls
                window.addEventListener('keydown', event => {
                    switch (event.key) {
                        case 'w':
                            jump();
                            break;
                        case 's':
                            crouch();
                            break;
                        default:
                            break;
                    }
                });

                const min = 1000;
                const range = 5000 - min + 1;
                const obstacleRadius = moonRadius / 100;
                const obstacleDiameter = obstacleRadius * 2;
                const offsetRadius = moonRadius + obstacleDiameter;
                const offsetDiameter = offsetRadius * 2;
                const visible = (offsetDiameter * Math.asin(Math.sqrt(
                    Math.pow(offsetRadius, 2) - Math.pow(offsetRadius - ((screenHeight * 0.25) + obstacleDiameter), 2)
                ) / offsetDiameter)) / offsetRadius;
                const screenOffset = (Math.PI / 2) - (visible / 2);
                const generateObstacle = () => {
                    window.setTimeout(() => {
                        const rotation = container.rotation;
                        const offset = (-rotation) - screenOffset;
                        obstacleQueue.push({
                            dieAt: rotation - visible,
                            displayObject: container.addChild(new PIXI.Graphics()
                                .beginFill(0x0000FF)
                                .drawCircle(
                                    moonRadius + (Math.cos(offset) * offsetRadius),
                                    moonRadius + (Math.sin(offset) * offsetRadius),
                                    obstacleRadius
                                )
                                .endFill())
                        });

                        ticker.addOnce(generateObstacle);
                    }, Math.floor(Math.random() * range) + min);
                };

                let speed = 0.002;
                ticker.add(delta => {
                    const rotation = container.rotation - (speed * delta);
                    container.rotation = rotation;
                    speed += 0.000001;
                    if (obstacleQueue.length > 0) {
                        const firstObstacle = obstacleQueue[0];
                        if (rotation <= firstObstacle.dieAt) {
                            firstObstacle.displayObject.destroy();
                            obstacleQueue.shift();
                        }
                    }
                });

                ticker.addOnce(generateObstacle);
            });
        }, { once: true });
    </script>
{% endblock %}
